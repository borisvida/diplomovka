\chapter{Complexity of A-transducers}
\label{chap:complexity}

\paragraph{}
This section is concerned with the complexity of A-transducers. Since the majority of the results published to this date involve sequential transducers and sequential functions, we try to investigate two new concepts in this area - nondeterminism and the fact, that we deal with pairs of languages, without exactly defined transduction.

\paragraph{}
However, at this time we do not have any universal way of proving the minimality of an A-transducer (in regard to number of states). For this reason, we would like to look at some special classes of transformations and languages and present the results concerning these.

%----------------------------------------------------------------------------
\section{"Modular-counting" languages}

\paragraph{}
Under "modular counting" languages we mean languages in the form \\
\centerline{$L_k = \{ a^k | k \equiv 0 (mod k) \} $.}

\paragraph{}
As we know, for a regular language $R$ (and therefore also, when $R$ is modular counting language), there always exists an A-transducer with $\mathscr{C}_{state}(R)$ states, which generates $R$ "from scratch", regardless of the input - we take the finite automaton for $R$ and alter its transition function from reading to generating symbols.

\paragraph{}
Formally, for an automaton $A = (Q, \Sigma, \delta, q_0, F)$ we can construct an A-transducer $T = (Q, \Sigma, \Sigma, H, q_0, F)$, where $H = \{ (p, \epsilon, a, q) | \delta (p, a) = q\} \cup \{ (q_0, a, \epsilon, q_0) | a \in \Sigma \} $. It is easy to see, that for any nonempty language $L$, $T(L) = R$.

\paragraph{}
However, the purpose of A-transducers clearly is to make the generating of languages easier using the input. Therefore, we would now like to present our results concerning the minimum complexity of an A-transducer for a pair of languages.

\paragraph{}
\oznacenie By $\gcd(a,b)$ we denote a greatest common divisor of integers $a, b$.

\paragraph{}
\clema For a pair of languages $L_k, L_l$, the minimal state complexity of an A-transudcer $T$, such that $T(L_k) = L_l$, is 
\begin{enumerate}
\item $l$, if $k$ and $l$ are coprime integers,
\item $\frac{l}{\gcd(k,l)}$, if $k \leq l$,
\item $\min(l,\frac{k}{\gcd(k,l)})$, if $k > l \land k < l^2$,
\item $l$, if $k \geq l^2$.
\end{enumerate}

\paragraph{}
\dokaz For sake of clarity, we prove the four parts of the Lemma separately. However, as stated before, $l$ states are always sufficient, so we have a natural upper bound for parts 1. and 4.
\begin{enumerate}
\item Let $T = (Q, \Sigma, \Sigma, H, q_0, F)$ be an A-transducer, such that $T(L_k) = L_l$. Let $T$ have $l-1$ states. Now, let us look at an accepting computation (in this case the sequence of states) of $T$ on some sufficiently long word $x \in L_k$ ($|x| \geq l$), by which $T$ generates a word $y \in L_l$. Clearly, there has to be a cycle, i. e. the computation has a form $q_0, q_1, ..., q_i, ..., q_j, ..., q_F$, where $q_F \in F$ and $q_i \equiv q_j$, while $j < i + l$ (we assume that this is the shortest cycle in the computation, during that $T$ generates a non-empty output). In this cycle, $T$ reads a subword $a^r$ and generates output $a^s, 1 \leq s \leq l-1$.

\paragraph{}
The two occurences of the state $q_i \equiv q_j$ in the sequence are indistinguishable from the point of view of $T$. Now, let us take two longer inputs $x' \equiv x.a^{k*r}$ and $x'' \equiv x.a^{2k*r}$. On these two inputs, $T$ generates outputs $y' \equiv y.a^{k*s}$ and $y'' \equiv y.a^{2k*s}$, respectively. Since $k$ and $l$ are coprime integers and $s < l$, $k*s$ is not divisible by $l$, therefore one of these outputs does not belong to $L_l$, while both $x', x'' \in L_k$. We have generated an incorrect output, thus $T$ cannot have less than $l$ states.

\item As claimed before, an A-transducer with $l$ states does the job. Therefore, in further we assume, that $\frac{k}{\gcd(k,l)} < l$.

\paragraph{}
First we will show, that $\frac{l}{\gcd(k,l)}$ states suffice. We can construct an A-transducer $T = (Q, \{ a\}, \{ a\}, H, q_0, F)$, where
\begin{itemize}
\item $Q = \{ q_0, q_1,  ..., q_{\frac{l}{\gcd(k,l)}-1 }\}$
\item $F = q_{\frac{l}{\gcd(k,l)}-1 }$
\item $H = \{(q_i, a, a, q_{i+1})| 0 \leq i < \frac{k}{\gcd(k,l)}-1 \} \cup \{(q_i, \epsilon, a, q_{i+1})| \frac{k}{\gcd(k,l)}-1 \leq i < \frac{l}{\gcd(k,l)}-2 \} \cup \{ (q_{\frac{l}{\gcd(k,l)}-1}, \epsilon, a, q_0) \}$.
\end{itemize}

\paragraph{}
It is easy to see, that the number of iterations of this cycle on a correct input (from $L_k$) is divisible by $\gcd(k,l)$. Each iteration creates $\frac{l}{\gcd(k,l)}$ symbols $a$ on the output, therefore $T(L_k) = L_l$.

\paragraph{}
Now we need to prove, that this number really forms a lower bound for state count: suppose, that there is an A-transducer $T' = (Q, \Sigma, \Sigma, H, q_0, F)$ with $\frac{l}{\gcd(k,l)} -1$ states. Similarly to the proof of part 1., we look for a cycle, in this case of the length $\frac{l}{\gcd(k,l)} - 1$ states. With very similar series of arguments, we can construct two inputs $x' \equiv x.a^{k*r}$ and $x'' \equiv x.a^{2k*r}$, which produce outputs $y' \equiv y.a^{k*s}$ and $y'' \equiv y.a^{2k*s}$, respectively. If both of these numbers were divisible by $l$, then also $k*s$ would be divisible by $l$. However, this is not possible, since $s < \frac{l}{\gcd(k,l)}$.  

\item Just like in part 2., we show, that if $k > l \land k < l^2$, then $\frac{k}{\gcd(k,l)}$ states is enough. The corresponding A-transducer will look as follows: $T = (Q, \{ a\}, \{ a\}, H, q_0, F)$, where 

\begin{itemize}
\item $Q = \{ q_0, q_1,  ..., q_{\frac{k}{\gcd(k,l)}-1 }\}$
\item $F = q_{\frac{l}{\gcd(k,l)}-1 }$
\item $H = \{(q_i, a, a, q_{i+1})| 0 \leq i < \frac{l}{\gcd(k,l)}-1 \} \cup \{(q_i, a, \epsilon, q_{i+1})| \frac{l}{\gcd(k,l)}-1 \leq i < \frac{k}{\gcd(k,l)}-2 \} \cup \{ (q_{\frac{k}{\gcd(k,l)}-1}, \epsilon, a, q_0) \}$.
\end{itemize}
\paragraph{}
For similar reason as in part 2., it is clear, that $T(L_k) = L_l$.

\paragraph{}
However, the second part of proof is a little different. We will not show, that an A-trandsucer $T' = (Q', \Sigma', \Sigma', H', q'_0, F')$ with fewer states, generates an incorrect output, but we claim, that it is not able to generate all correct outputs (i. e. outputs from language $L_l$).

\paragraph{}
Once again, we look for a cycle in the computation of $T'$. Since $|Q'| < \frac{k}{\gcd(k,l)}$, to produce an output of some greater length the computation must have a form $q'_0, q'_1, ..., q'_i, ..., q'_j, ..., q'_F$, where $q'_F \in F'$ and $q'_i \equiv q'_j$, while $j < i + \frac{k}{\gcd(k,l)}$. In each of iterations of this cycle, $T$ has to output at least one symbol $a$ (again, we assume that this is the shortest cycle in the computation with non-empty output). Now consider a input fixed $x \in L_k, T'(x) = y \in L_l$. What is the next shortest correct input word $x'$?

\paragraph{}
Without loss of generality, assume, that our cycle reads $r$ symbols $a$ and writes $s$ of them on the output, $r,s < \frac{k}{\gcd(k,l)}$. We look for a smallest number $t$, such that $(t+1)*r$ is divisible by $k$ and $(t+1)*s$ is divisible by $l$ (we have also have to secure the correctness of both the input and the output). However, since both $r,s < \frac{k}{\gcd(k,l)}$, a smallest such number is their least common multiple, which is strictly greater than $l$, because $k > l$. But this means, that we cannot generate an output $y.a^l$ and therefore $L_l \not\subset T(L_k)$.

\color{red}ToDo: treba odovodnit, ze to plati pre akykolvek cyklus, takze nemozme generovat nejako inak\color{black}

\color{red}ToDo: tieto argumenty treba obhajit nejakou teoriou cisel (ak su vobec korektne), mozno nejaka cinska zvyskova/eulerova veta\color{black}

\item This part follows directly from previous claim - if $k \geq l^2$, then $l \leq \frac{k}{\gcd(k,l)}$ and therefore it is easier to generate $L_l$ "from scratch", using an A-transducer based on its final automaton (see above).
\end{enumerate}

\square

\paragraph{}
\cveta We can summarize previous lemmas in following claim: \\
\centerline{$\mathscr{C}_{state}(L_k, L_l) = \min (l, \frac{\max (k,l)}{\gcd (k,l)})$}.

%----------------------------------------------------------------------------
\section{Common transformations}

\paragraph{}
ToDo: dovodit, preco je to uzitocne (vyuzijeme pri advisors, hopefully)

\paragraph{}
ToDo: nejak rozumne formulovat vysledok toho tvaru, ze na zmenu abecedy z k-arnej na l-arnu treba nejaky logaritmus stavov

\paragraph{}
ToDo: vysledky pri pocitani XOR s nejakym specific klucom
